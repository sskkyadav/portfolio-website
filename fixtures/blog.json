[
{
    "model": "blog.blogpost",
    "pk": 1,
    "fields": {
        "title": "Getting Started with Django: A Complete Guide",
        "slug": "getting-started-with-django",
        "content": "Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design. In this comprehensive guide, we will walk through everything you need to know to get started with Django.\n\nWhy Choose Django?\n\nDjango follows the \"batteries included\" philosophy, providing everything you need to build web applications out of the box. Key features include:\n\n- ORM (Object-Relational Mapping): Database abstraction layer\n- Admin Interface: Automatic admin panel for content management\n- URL Routing: Clean, readable URL patterns\n- Template Engine: Powerful templating system\n- Security: Built-in protection against common web vulnerabilities\n\nInstallation and Setup\n\nFirst, make sure you have Python installed. Then create a virtual environment and install Django:\n\npython -m venv myenv\nsource myenv/bin/activate  # On Windows: myenv\\Scripts\\activate\npip install django\n\nCreating Your First Project\n\ndjango-admin startproject myproject\ncd myproject\npython manage.py runserver\n\nNext Steps\n\nOnce you have Django installed, you can start building your first application. Django's documentation is excellent, so make sure to check it out as you progress.",
        "excerpt": "Learn how to get started with Django, the popular Python web framework, with this comprehensive guide covering installation, setup, and your first project.",
        "image": "static/images/suresh.jpg",
        "author": 1,
        "tags": [
            "Django",
            "Python",
            "Web Development",
            "Tutorial"
        ],
        "published": true,
        "published_at": "2025-11-03T14:30:55.273Z",
        "created_at": "2025-11-03T14:30:55.276Z",
        "updated_at": "2025-11-05T16:37:09.480Z"
    }
},
{
    "model": "blog.blogpost",
    "pk": 2,
    "fields": {
        "title": "React vs Vue.js: Which Framework Should You Choose?",
        "slug": "react-vs-vue-js-comparison",
        "content": "Choosing between React and Vue.js can be challenging. Both are excellent JavaScript frameworks with strong communities and extensive ecosystems. Let us compare them to help you make an informed decision.\n\nReact Overview\n\nReact, developed by Facebook, is a component-based library for building user interfaces. It has been around since 2013 and has a massive community.\n\nPros:\n- Largest ecosystem and community\n- Backed by Facebook\n- Excellent for large-scale applications\n- Rich ecosystem of libraries and tools\n\nCons:\n- Steeper learning curve\n- Requires additional libraries for routing and state management\n- JSX syntax can be polarizing\n\nVue.js Overview\n\nVue.js, created by Evan You, is a progressive framework for building user interfaces. It is designed to be incrementally adoptable.\n\nPros:\n- Gentle learning curve\n- Excellent documentation\n- Built-in state management and routing\n- Smaller bundle size\n- Great for smaller to medium projects\n\nCons:\n- Smaller community compared to React\n- Fewer job opportunities\n- Less corporate backing\n\nWhich Should You Choose?\n\nThe choice depends on your project requirements and team preferences:\n\n- Choose React if you are working on large-scale applications, have experience with JavaScript, or want maximum flexibility\n- Choose Vue.js if you are new to frontend development, working on smaller projects, or prefer a more straightforward approach\n\nBoth frameworks are excellent choices and will serve you well in your web development journey.",
        "excerpt": "Compare React and Vue.js to determine which JavaScript framework is best for your next project. Learn the pros, cons, and use cases for each.",
        "image": "static/images/suresh1.jpg",
        "author": 1,
        "tags": [
            "React",
            "Vue.js",
            "JavaScript",
            "Frontend"
        ],
        "published": true,
        "published_at": "2025-11-03T14:30:55.273Z",
        "created_at": "2025-11-03T14:30:55.287Z",
        "updated_at": "2025-11-05T16:37:09.498Z"
    }
},
{
    "model": "blog.blogpost",
    "pk": 3,
    "fields": {
        "title": "Introduction to Machine Learning with Python",
        "slug": "introduction-to-machine-learning-python",
        "content": "Machine Learning is revolutionizing industries across the globe. In this introductory guide, we will explore the fundamentals of ML using Python and popular libraries like scikit-learn.\n\nWhat is Machine Learning?\n\nMachine Learning is a subset of artificial intelligence that enables computers to learn and make decisions from data without being explicitly programmed.\n\nTypes of Machine Learning:\n\n1. Supervised Learning: Learning from labeled data\n2. Unsupervised Learning: Finding patterns in unlabeled data\n3. Reinforcement Learning: Learning through trial and error\n\nGetting Started with Python ML\n\nPython has become the go-to language for machine learning due to its simplicity and extensive libraries.\n\nEssential Libraries:\n\n- NumPy: Numerical computing\n- Pandas: Data manipulation and analysis\n- Matplotlib/Seaborn: Data visualization\n- Scikit-learn: Machine learning algorithms\n- TensorFlow/PyTorch: Deep learning frameworks\n\nA Simple Example\n\nLet us create a basic linear regression model:\n\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\n\n# Sample data\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([2, 4, 6, 8, 10])\n\n# Split data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Create and train model\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\n# Make predictions\npredictions = model.predict(X_test)\n\nNext Steps\n\nMachine Learning is a vast field with endless possibilities. Start with simple projects and gradually explore more complex algorithms and deep learning techniques.",
        "excerpt": "Discover the fundamentals of machine learning with Python. Learn about different types of ML, essential libraries, and build your first ML model.",
        "image": "static/images/suresh.jpg",
        "author": 1,
        "tags": [
            "Machine Learning",
            "Python",
            "AI",
            "Data Science"
        ],
        "published": true,
        "published_at": "2025-11-03T14:30:55.273Z",
        "created_at": "2025-11-03T14:30:55.293Z",
        "updated_at": "2025-11-05T16:37:09.507Z"
    }
},
{
    "model": "blog.blogpost",
    "pk": 4,
    "fields": {
        "title": "Building REST APIs with Django REST Framework",
        "slug": "building-rest-apis-django-rest-framework",
        "content": "Django REST Framework (DRF) is a powerful toolkit for building Web APIs in Django. It provides everything you need to create robust, scalable REST APIs quickly and easily.\n\nWhy Use Django REST Framework?\n\nDRF builds on Django's strengths and adds powerful features for API development:\n\n- Serialization: Convert complex data types to JSON\n- Authentication: Built-in and custom authentication methods\n- Permissions: Control access to API endpoints\n- Throttling: Rate limiting for API requests\n- Pagination: Handle large datasets efficiently\n- Documentation: Auto-generated API documentation\n\nInstallation and Setup\n\npip install djangorestframework\n\nAdd to your INSTALLED_APPS:\n\nINSTALLED_APPS = [\n    # ... other apps\n    'rest_framework',\n]\n\nCreating Your First API\n\nLet us create a simple API for managing blog posts:\n\n# models.py\nfrom django.db import models\n\nclass Post(models.Model):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    created_at = models.DateTimeField(auto_now_add=True)\n\n# serializers.py\nfrom rest_framework import serializers\nfrom .models import Post\n\nclass PostSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Post\n        fields = '__all__'\n\n# views.py\nfrom rest_framework import viewsets\nfrom .models import Post\nfrom .serializers import PostSerializer\n\nclass PostViewSet(viewsets.ModelViewSet):\n    queryset = Post.objects.all()\n    serializer_class = PostSerializer\n\n# urls.py\nfrom django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\nfrom . import views\n\nrouter = DefaultRouter()\nrouter.register(r'posts', views.PostViewSet)\n\nurlpatterns = [\n    path('api/', include(router.urls)),\n]\n\nTesting Your API\n\nDRF provides a browsable API interface. Visit http://127.0.0.1:8000/api/posts/ to see your API in action.\n\nAdvanced Features\n\nDRF offers many advanced features:\n\n- Custom authentication classes\n- Permission classes\n- Filtering and searching\n- Versioning\n- Schema generation\n\nStart building APIs with DRF and experience the power of Django for backend development.",
        "excerpt": "Learn how to build powerful REST APIs using Django REST Framework. From basic setup to advanced features, create scalable web APIs.",
        "image": "static/images/suresh1.jpg",
        "author": 1,
        "tags": [
            "Django",
            "REST API",
            "DRF",
            "Backend"
        ],
        "published": true,
        "published_at": "2025-11-03T14:30:55.273Z",
        "created_at": "2025-11-03T14:30:55.302Z",
        "updated_at": "2025-11-05T16:37:09.517Z"
    }
},
{
    "model": "blog.blogpost",
    "pk": 5,
    "fields": {
        "title": "Mastering CSS Grid and Flexbox for Modern Layouts",
        "slug": "mastering-css-grid-flexbox-modern-layouts",
        "content": "CSS Grid and Flexbox are powerful layout systems that have revolutionized web design. Understanding when and how to use each will make you a more effective frontend developer.\n\nCSS Flexbox\n\nFlexbox is designed for one-dimensional layouts - either a row or a column.\n\nKey Concepts:\n\n- Container: The parent element with display: flex\n- Items: The child elements\n- Main Axis: The primary axis (horizontal by default)\n- Cross Axis: The perpendicular axis\n\nCommon Use Cases:\n\n- Navigation bars\n- Card layouts\n- Centering content\n- Equal height columns\n\n.container {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.item {\n  flex: 1;\n}\n\nCSS Grid\n\nGrid is designed for two-dimensional layouts - both rows and columns simultaneously.\n\nKey Concepts:\n\n- Grid Container: Parent with display: grid\n- Grid Items: Child elements\n- Grid Lines: The lines that form the grid\n- Grid Tracks: The spaces between grid lines\n- Grid Areas: Rectangular areas defined by grid line\n\nCommon Use Cases:\n\n- Page layouts\n- Complex forms\n- Image galleries\n- Dashboard layouts\n\n.container {\n  display: grid;\n  grid-template-columns: 1fr 2fr 1fr;\n  grid-template-rows: auto 1fr auto;\n  gap: 20px;\n}\n\n.header {\n  grid-column: 1 / -1;\n}\n\n.sidebar {\n  grid-row: 2 / 3;\n}\n\n.main {\n  grid-row: 2 / 3;\n  grid-column: 2 / 3;\n}\n\nWhen to Use Which?\n\n- Use Flexbox for:\n  - One-dimensional layouts\n  - Content that needs to wrap\n  - Aligning items within a container\n\n- Use Grid for:\n  - Two-dimensional layouts\n  - Complex page layouts\n  - When you need precise control over positioning\n\nBrowser Support\n\nBoth Flexbox and Grid have excellent browser support. Use Autoprefixer to handle vendor prefixes for older browsers.\n\nBest Practices\n\n1. Start with mobile-first design\n2. Use Grid for page layouts, Flexbox for components\n3. Combine both when needed\n4. Test across different screen sizes\n5. Use CSS custom properties for responsive design\n\nMastering these layout systems will give you the tools to create modern, responsive web designs that work across all devices.",
        "excerpt": "Master CSS Grid and Flexbox for creating modern, responsive web layouts. Learn when to use each and best practices for web design.",
        "image": "static/images/suresh.jpg",
        "author": 1,
        "tags": [
            "CSS",
            "Grid",
            "Flexbox",
            "Layout",
            "Responsive"
        ],
        "published": true,
        "published_at": "2025-11-03T14:30:55.273Z",
        "created_at": "2025-11-03T14:30:55.311Z",
        "updated_at": "2025-11-05T16:37:09.525Z"
    }
},
{
    "model": "blog.blogpost",
    "pk": 6,
    "fields": {
        "title": "Getting Started with Django REST Framework",
        "slug": "getting-started-django-rest-framework",
        "content": "\n# Getting Started with Django REST Framework\n\nDjango REST Framework (DRF) is a powerful toolkit for building Web APIs in Django. In this comprehensive guide, we'll explore how to create robust REST APIs that can power modern web and mobile applications.\n\n## Why Django REST Framework?\n\nDRF provides:\n- **Serialization** that supports both ORM and non-ORM data sources\n- **Authentication** policies including packages for OAuth1a and OAuth2\n- **Throttling** for rate limiting access to your API\n- **Pagination** for handling large datasets\n- **Versioning** for managing API versions\n- **Browsable API** for easy testing and exploration\n\n## Installation and Setup\n\nFirst, install DRF using pip:\n\n```bash\npip install djangorestframework\n```\n\nAdd it to your `INSTALLED_APPS` in `settings.py`:\n\n```python\nINSTALLED_APPS = [\n    # ... other apps\n    'rest_framework',\n]\n```\n\n## Creating Your First API View\n\nLet's create a simple API endpoint that returns a list of blog posts:\n\n```python\nfrom rest_framework import generics\nfrom rest_framework.permissions import IsAuthenticatedOrReadOnly\nfrom .models import BlogPost\nfrom .serializers import BlogPostSerializer\n\nclass BlogPostListCreateView(generics.ListCreateAPIView):\n    queryset = BlogPost.objects.all()\n    serializer_class = BlogPostSerializer\n    permission_classes = [IsAuthenticatedOrReadOnly]\n```\n\n## Serializers\n\nSerializers convert complex data types like Django model instances to Python data types that can be easily rendered into JSON:\n\n```python\nfrom rest_framework import serializers\nfrom .models import BlogPost\n\nclass BlogPostSerializer(serializers.ModelSerializer):\n    author_name = serializers.CharField(source='author', read_only=True)\n\n    class Meta:\n        model = BlogPost\n        fields = ['id', 'title', 'slug', 'content', 'excerpt', 'author_name', 'published_at']\n        read_only_fields = ['id', 'slug', 'published_at']\n```\n\n## Authentication and Permissions\n\nDRF provides several authentication methods:\n\n- **SessionAuthentication**: For web browsers\n- **TokenAuthentication**: For API clients\n- **BasicAuthentication**: For simple cases\n\n```python\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': [\n        'rest_framework.authentication.SessionAuthentication',\n        'rest_framework.authentication.TokenAuthentication',\n    ],\n    'DEFAULT_PERMISSION_CLASSES': [\n        'rest_framework.permissions.IsAuthenticatedOrReadOnly',\n    ],\n}\n```\n\n## Testing Your API\n\nDRF includes a browsable API that allows you to test endpoints directly from your browser. Simply navigate to your API endpoint, and you'll see an interactive interface.\n\n## Conclusion\n\nDjango REST Framework makes it incredibly easy to build powerful APIs. With its extensive feature set and excellent documentation, you can quickly create production-ready APIs that scale with your application.\n\nThe key to success with DRF is understanding the separation of concerns between views, serializers, and permissions. Once you grasp these concepts, building complex APIs becomes straightforward.\n            ",
        "excerpt": "Learn how to build powerful REST APIs with Django REST Framework. This comprehensive guide covers installation, serialization, authentication, and best practices.",
        "image": "/static/images/suresh.jpg",
        "author": 1,
        "tags": "Django, REST API, Python, Web Development",
        "published": true,
        "published_at": null,
        "created_at": "2025-11-05T11:24:28.364Z",
        "updated_at": "2025-11-05T16:44:34.558Z"
    }
},
{
    "model": "blog.blogpost",
    "pk": 7,
    "fields": {
        "title": "React Hooks: A Complete Guide for Beginners",
        "slug": "react-hooks-complete-guide",
        "content": "\n# React Hooks: A Complete Guide for Beginners\n\nReact Hooks revolutionized how we write React components. Introduced in React 16.8, hooks allow you to use state and other React features without writing a class component. This guide will take you from hooks basics to advanced patterns.\n\n## What Are React Hooks?\n\nHooks are functions that let you \"hook into\" React state and lifecycle features from function components. They let you use React without classes.\n\n## useState: Managing Component State\n\nThe `useState` hook is the most fundamental hook. It allows you to add state to functional components:\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n## useEffect: Handling Side Effects\n\n`useEffect` lets you perform side effects in function components. It serves the same purpose as `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` in class components:\n\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    // This runs after every render\n    fetch(`/api/users/${userId}`)\n      .then(response => response.json())\n      .then(data => setUser(data));\n\n    // Cleanup function (optional)\n    return () => {\n      // This runs when component unmounts or before next effect\n    };\n  }, [userId]); // Only re-run if userId changes\n\n  if (!user) return <div>Loading...</div>;\n\n  return <div>Welcome, {user.name}!</div>;\n}\n```\n\n## useContext: Accessing Context\n\n`useContext` makes it easy to consume context values:\n\n```jsx\nimport React, { useContext } from 'react';\nimport { ThemeContext } from './ThemeProvider';\n\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n\n  return (\n    <button style={{ background: theme.background, color: theme.foreground }}>\n      I am styled with theme context!\n    </button>\n  );\n}\n```\n\n## Custom Hooks: Reusable Logic\n\nYou can create your own hooks to extract component logic into reusable functions:\n\n```jsx\nimport { useState, useEffect } from 'react';\n\nfunction useLocalStorage(key, initialValue) {\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      return initialValue;\n    }\n  });\n\n  const setValue = value => {\n    try {\n      setStoredValue(value);\n      window.localStorage.setItem(key, JSON.stringify(value));\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  return [storedValue, setValue];\n}\n\n// Usage\nfunction MyComponent() {\n  const [name, setName] = useLocalStorage('name', 'John');\n\n  return (\n    <input\n      value={name}\n      onChange={e => setName(e.target.value)}\n    />\n  );\n}\n```\n\n## Rules of Hooks\n\n1. **Only call hooks at the top level** - Don't call hooks inside loops, conditions, or nested functions\n2. **Only call hooks from React functions** - Call them from React function components or custom hooks\n3. **Hook names must start with \"use\"** - This is a convention that helps with automatic linting\n\n## Common Hook Patterns\n\n### Data Fetching\n```jsx\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    fetch(url)\n      .then(response => response.json())\n      .then(data => {\n        setData(data);\n        setLoading(false);\n      })\n      .catch(error => {\n        setError(error);\n        setLoading(false);\n      });\n  }, [url]);\n\n  return { data, loading, error };\n}\n```\n\n### Form Handling\n```jsx\nfunction useForm(initialValues) {\n  const [values, setValues] = useState(initialValues);\n\n  const handleChange = e => {\n    setValues({\n      ...values,\n      [e.target.name]: e.target.value\n    });\n  };\n\n  const reset = () => setValues(initialValues);\n\n  return [values, handleChange, reset];\n}\n```\n\n## Conclusion\n\nReact Hooks have transformed React development by making it easier to share logic between components and reducing the need for class components. While there's a learning curve, the benefits of cleaner, more reusable code make it worthwhile.\n\nStart small by converting simple class components to function components with hooks, and gradually work your way up to more complex patterns. The React documentation and community resources are excellent for deepening your understanding.\n            ",
        "excerpt": "Master React Hooks from basics to advanced patterns. Learn useState, useEffect, useContext, and how to create custom hooks for reusable logic.",
        "image": "static/images/suresh.jpg",
        "author": 1,
        "tags": "React, JavaScript, Hooks, Frontend",
        "published": true,
        "published_at": null,
        "created_at": "2025-11-05T11:24:28.375Z",
        "updated_at": "2025-11-05T16:44:34.571Z"
    }
},
{
    "model": "blog.blogpost",
    "pk": 8,
    "fields": {
        "title": "Building Modern Web Applications with Django and React",
        "slug": "building-modern-web-apps-django-react",
        "content": "\n# Building Modern Web Applications with Django and React\n\nCombining Django's powerful backend capabilities with React's dynamic frontend creates a robust full-stack solution. This guide explores best practices for integrating these technologies to build scalable, maintainable web applications.\n\n## Why Django + React?\n\nDjango and React complement each other perfectly:\n- **Django** provides a secure, scalable backend with excellent ORM and admin interface\n- **React** delivers fast, interactive user interfaces with component-based architecture\n- Together they enable separation of concerns and team specialization\n\n## Project Structure\n\nA typical Django + React project structure:\n\n```\nmyproject/\n├── backend/\n│   ├── manage.py\n│   ├── myapp/\n│   │   ├── models.py\n│   │   ├── views.py\n│   │   ├── serializers.py\n│   │   └── urls.py\n│   └── requirements.txt\n├── frontend/\n│   ├── src/\n│   │   ├── components/\n│   │   ├── pages/\n│   │   ├── services/\n│   │   └── App.js\n│   ├── package.json\n│   └── public/\n└── docker-compose.yml\n```\n\n## Django REST Framework Setup\n\nFirst, set up your Django backend with DRF:\n\n```python\n# settings.py\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'rest_framework',\n    'corsheaders',  # For CORS handling\n    'myapp',\n]\n\nMIDDLEWARE = [\n    # ... other middleware\n    'corsheaders.middleware.CorsMiddleware',\n    'django.middleware.common.CommonMiddleware',\n]\n\n# Allow all origins for development\nCORS_ALLOWED_ORIGINS = [\n    \"http://localhost:3000\",\n    \"http://127.0.0.1:3000\",\n]\n```\n\n## API Design\n\nDesign RESTful APIs that your React frontend can consume:\n\n```python\n# views.py\nfrom rest_framework import viewsets\nfrom .models import Task\nfrom .serializers import TaskSerializer\n\nclass TaskViewSet(viewsets.ModelViewSet):\n    queryset = Task.objects.all()\n    serializer_class = TaskSerializer\n```\n\n```python\n# serializers.py\nfrom rest_framework import serializers\nfrom .models import Task\n\nclass TaskSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Task\n        fields = ['id', 'title', 'description', 'completed', 'created_at']\n```\n\n## React Frontend Setup\n\nCreate a React app and set up API communication:\n\n```jsx\n// src/services/api.js\nimport axios from 'axios';\n\nconst api = axios.create({\n  baseURL: process.env.REACT_APP_API_URL || 'http://localhost:8000/api',\n});\n\n// Add request interceptor for authentication\napi.interceptors.request.use(\n  config => {\n    const token = localStorage.getItem('token');\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    return config;\n  },\n  error => Promise.reject(error)\n);\n\nexport default api;\n```\n\n## State Management\n\nUse React hooks and Context API for state management:\n\n```jsx\n// src/contexts/TaskContext.js\nimport React, { createContext, useContext, useReducer, useEffect } from 'react';\nimport api from '../services/api';\n\nconst TaskContext = createContext();\n\nconst taskReducer = (state, action) => {\n  switch (action.type) {\n    case 'SET_TASKS':\n      return { ...state, tasks: action.payload, loading: false };\n    case 'ADD_TASK':\n      return { ...state, tasks: [...state.tasks, action.payload] };\n    case 'UPDATE_TASK':\n      return {\n        ...state,\n        tasks: state.tasks.map(task =>\n          task.id === action.payload.id ? action.payload : task\n        )\n      };\n    case 'DELETE_TASK':\n      return {\n        ...state,\n        tasks: state.tasks.filter(task => task.id !== action.payload)\n      };\n    default:\n      return state;\n  }\n};\n\nexport const TaskProvider = ({ children }) => {\n  const [state, dispatch] = useReducer(taskReducer, {\n    tasks: [],\n    loading: true\n  });\n\n  useEffect(() => {\n    fetchTasks();\n  }, []);\n\n  const fetchTasks = async () => {\n    try {\n      const response = await api.get('/tasks/');\n      dispatch({ type: 'SET_TASKS', payload: response.data });\n    } catch (error) {\n      console.error('Error fetching tasks:', error);\n    }\n  };\n\n  const addTask = async (taskData) => {\n    try {\n      const response = await api.post('/tasks/', taskData);\n      dispatch({ type: 'ADD_TASK', payload: response.data });\n    } catch (error) {\n      console.error('Error adding task:', error);\n    }\n  };\n\n  const updateTask = async (id, taskData) => {\n    try {\n      const response = await api.put(`/tasks/${id}/`, taskData);\n      dispatch({ type: 'UPDATE_TASK', payload: response.data });\n    } catch (error) {\n      console.error('Error updating task:', error);\n    }\n  };\n\n  const deleteTask = async (id) => {\n    try {\n      await api.delete(`/tasks/${id}/`);\n      dispatch({ type: 'DELETE_TASK', payload: id });\n    } catch (error) {\n      console.error('Error deleting task:', error);\n    }\n  };\n\n  return (\n    <TaskContext.Provider value={{\n      ...state,\n      addTask,\n      updateTask,\n      deleteTask\n    }}>\n      {children}\n    </TaskContext.Provider>\n  );\n};\n\nexport const useTasks = () => {\n  const context = useContext(TaskContext);\n  if (!context) {\n    throw new Error('useTasks must be used within a TaskProvider');\n  }\n  return context;\n};\n```\n\n## Component Architecture\n\nCreate reusable components:\n\n```jsx\n// src/components/TaskList.js\nimport React from 'react';\nimport { useTasks } from '../contexts/TaskContext';\nimport TaskItem from './TaskItem';\n\nconst TaskList = () => {\n  const { tasks, loading } = useTasks();\n\n  if (loading) return <div>Loading tasks...</div>;\n\n  return (\n    <div className=\"task-list\">\n      {tasks.map(task => (\n        <TaskItem key={task.id} task={task} />\n      ))}\n    </div>\n  );\n};\n\nexport default TaskList;\n```\n\n```jsx\n// src/components/TaskItem.js\nimport React from 'react';\nimport { useTasks } from '../contexts/TaskContext';\n\nconst TaskItem = ({ task }) => {\n  const { updateTask, deleteTask } = useTasks();\n\n  const handleToggle = () => {\n    updateTask(task.id, { ...task, completed: !task.completed });\n  };\n\n  const handleDelete = () => {\n    if (window.confirm('Are you sure you want to delete this task?')) {\n      deleteTask(task.id);\n    }\n  };\n\n  return (\n    <div className={`task-item ${task.completed ? 'completed' : ''}`}>\n      <input\n        type=\"checkbox\"\n        checked={task.completed}\n        onChange={handleToggle}\n      />\n      <span>{task.title}</span>\n      <button onClick={handleDelete}>Delete</button>\n    </div>\n  );\n};\n\nexport default TaskItem;\n```\n\n## Authentication\n\nImplement authentication with JWT:\n\n```python\n# Django - views.py\nfrom rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView\n\n# Add to urls.py\nurlpatterns = [\n    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),\n    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),\n]\n```\n\n```jsx\n// React - AuthContext.js\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport api from '../services/api';\n\nconst AuthContext = createContext();\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const token = localStorage.getItem('token');\n    if (token) {\n      // Verify token and set user\n      api.get('/auth/user/')\n        .then(response => setUser(response.data))\n        .catch(() => localStorage.removeItem('token'))\n        .finally(() => setLoading(false));\n    } else {\n      setLoading(false);\n    }\n  }, []);\n\n  const login = async (username, password) => {\n    try {\n      const response = await api.post('/api/token/', { username, password });\n      const { access, refresh } = response.data;\n\n      localStorage.setItem('token', access);\n      localStorage.setItem('refreshToken', refresh);\n\n      // Get user data\n      const userResponse = await api.get('/auth/user/');\n      setUser(userResponse.data);\n\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: error.response?.data?.detail || 'Login failed' };\n    }\n  };\n\n  const logout = () => {\n    localStorage.removeItem('token');\n    localStorage.removeItem('refreshToken');\n    setUser(null);\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, login, logout, loading }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n```\n\n## Deployment\n\nDeploy your application using Docker:\n\n```yaml\nversion: '3.8'\n\nservices:\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_DB: myproject\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n\n  backend:\n    build: ./backend\n    command: python manage.py runserver 0.0.0.0:8000\n    volumes:\n      - ./backend:/code\n    ports:\n      - \"8000:8000\"\n    depends_on:\n      - db\n    environment:\n      DATABASE_URL: postgres://user:password@db:5432/myproject\n\n  frontend:\n    build: ./frontend\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - ./frontend:/app\n      - /app/node_modules\n```\n\n## Best Practices\n\n1. **API Versioning**: Use URL versioning (e.g., `/api/v1/tasks/`)\n2. **Error Handling**: Implement comprehensive error handling on both frontend and backend\n3. **Testing**: Write unit tests for both Django and React code\n4. **Security**: Use HTTPS, validate inputs, and implement proper authentication\n5. **Performance**: Implement caching, pagination, and lazy loading\n6. **Documentation**: Document your APIs with tools like Swagger/OpenAPI\n\n## Conclusion\n\nDjango and React together provide an excellent foundation for modern web applications. By following the patterns outlined in this guide, you can build scalable, maintainable applications that provide great user experiences.\n\nThe key to success is maintaining clear separation between frontend and backend concerns while ensuring smooth communication between them. With proper planning and architecture, this stack can handle everything from small projects to large-scale applications.\n            ",
        "excerpt": "Learn how to build full-stack web applications using Django for the backend and React for the frontend. Includes authentication, state management, and deployment.",
        "image": "static/images/suresh1.jpg",
        "author": 1,
        "tags": "Django, React, Full-Stack, Web Development",
        "published": true,
        "published_at": null,
        "created_at": "2025-11-05T11:24:28.384Z",
        "updated_at": "2025-11-05T16:44:34.582Z"
    }
},
{
    "model": "blog.blogpost",
    "pk": 9,
    "fields": {
        "title": "Python Best Practices for Clean and Maintainable Code",
        "slug": "python-best-practices-clean-code",
        "content": "\n# Python Best Practices for Clean and Maintainable Code\n\nWriting clean, maintainable Python code is crucial for long-term project success. This guide covers essential practices, patterns, and tools that will help you write better Python code.\n\n## Code Style and Formatting\n\n### PEP 8 Compliance\n\nFollow PEP 8, Python's official style guide:\n\n```python\n# Good\ndef calculate_total(price, tax_rate):\n    \"\"\"Calculate total price including tax.\"\"\"\n    return price * (1 + tax_rate)\n\n# Bad\ndef calculateTotal(price,tax_rate):\n    return price*(1+tax_rate)\n```\n\n### Use Black for Consistent Formatting\n\nBlack is an uncompromising code formatter:\n\n```bash\npip install black\nblack my_module.py\n```\n\n### Type Hints\n\nAdd type hints for better code documentation and IDE support:\n\n```python\nfrom typing import List, Optional\n\ndef process_items(items: List[str], limit: Optional[int] = None) -> List[str]:\n    \"\"\"Process a list of items with optional limit.\"\"\"\n    if limit:\n        return items[:limit]\n    return items\n```\n\n## Project Structure\n\nOrganize your project logically:\n\n```\nmyproject/\n├── src/\n│   ├── __init__.py\n│   ├── main.py\n│   └── mymodule/\n│       ├── __init__.py\n│       ├── models.py\n│       ├── views.py\n│       └── utils.py\n├── tests/\n│   ├── __init__.py\n│   ├── test_models.py\n│   └── test_views.py\n├── docs/\n├── requirements.txt\n├── setup.py\n└── README.md\n```\n\n## Writing Clean Functions\n\n### Single Responsibility Principle\n\nEach function should do one thing well:\n\n```python\n# Good\ndef validate_email(email: str) -> bool:\n    \"\"\"Validate email format.\"\"\"\n    import re\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n\ndef send_welcome_email(email: str) -> None:\n    \"\"\"Send welcome email to user.\"\"\"\n    if validate_email(email):\n        # Send email logic\n        pass\n\n# Bad\ndef process_user(email: str) -> None:\n    \"\"\"This function does too many things.\"\"\"\n    # Validate email\n    # Save to database\n    # Send welcome email\n    # Log activity\n    pass\n```\n\n### Function Length\n\nKeep functions short and focused:\n\n```python\n# Good\ndef calculate_order_total(items: List[dict]) -> float:\n    \"\"\"Calculate total price of order items.\"\"\"\n    subtotal = sum(item['price'] * item['quantity'] for item in items)\n    tax = subtotal * 0.08  # 8% tax\n    return subtotal + tax\n\n# Avoid functions longer than 50 lines\n```\n\n### Descriptive Names\n\nUse descriptive, meaningful names:\n\n```python\n# Good\ndef calculate_monthly_revenue(sales_data: List[dict]) -> float:\n    pass\n\n# Bad\ndef calc_rev(data: List[dict]) -> float:\n    pass\n```\n\n## Error Handling\n\n### Use Specific Exceptions\n\n```python\n# Good\nclass InsufficientFundsError(Exception):\n    pass\n\ndef withdraw(account: dict, amount: float) -> None:\n    if account['balance'] < amount:\n        raise InsufficientFundsError(\"Insufficient funds\")\n    account['balance'] -= amount\n\n# Bad\ndef withdraw(account: dict, amount: float) -> None:\n    if account['balance'] < amount:\n        raise ValueError(\"Not enough money\")\n```\n\n### Context Managers\n\nUse context managers for resource management:\n\n```python\n# Good\nwith open('data.txt', 'r') as file:\n    data = file.read()\n\n# Custom context manager\nfrom contextlib import contextmanager\n\n@contextmanager\ndef database_connection():\n    connection = create_connection()\n    try:\n        yield connection\n    finally:\n        connection.close()\n\nwith database_connection() as conn:\n    # Use connection\n    pass\n```\n\n## Testing\n\n### Write Comprehensive Tests\n\n```python\nimport pytest\nfrom mymodule import calculate_total, validate_email\n\nclass TestCalculateTotal:\n    def test_basic_calculation(self):\n        assert calculate_total(100, 0.08) == 108.0\n\n    def test_zero_tax(self):\n        assert calculate_total(100, 0) == 100.0\n\n    def test_high_tax(self):\n        assert calculate_total(100, 0.5) == 150.0\n\nclass TestValidateEmail:\n    def test_valid_emails(self):\n        assert validate_email('user@example.com')\n        assert validate_email('test.email+tag@domain.co.uk')\n\n    def test_invalid_emails(self):\n        assert not validate_email('invalid-email')\n        assert not validate_email('@domain.com')\n```\n\n### Test Coverage\n\nAim for high test coverage:\n\n```bash\npip install pytest-cov\npytest --cov=mymodule --cov-report=html\n```\n\n## Documentation\n\n### Docstrings\n\nWrite comprehensive docstrings:\n\n```python\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number.\n\n    Args:\n        n: The position in the Fibonacci sequence (0-indexed)\n\n    Returns:\n        The nth Fibonacci number\n\n    Raises:\n        ValueError: If n is negative\n\n    Examples:\n        >>> fibonacci(0)\n        0\n        >>> fibonacci(1)\n        1\n        >>> fibonacci(5)\n        5\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n```\n\n### README and Documentation\n\nMaintain comprehensive documentation:\n\n```markdown\n# My Project\n\nA Python library for [purpose].\n\n## Installation\n\n```bash\npip install myproject\n```\n\n## Usage\n\n```python\nfrom myproject import MyClass\n\nobj = MyClass()\nobj.do_something()\n```\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Write tests\n4. Submit a pull request\n```\n\n## Code Quality Tools\n\n### Linting\n\nUse multiple linters for comprehensive checking:\n\n```bash\npip install flake8 pylint mypy\n\n# Run linters\nflake8 mymodule.py\npylint mymodule.py\nmypy mymodule.py\n```\n\n### Pre-commit Hooks\n\nUse pre-commit to run checks before commits:\n\n```yaml\n# .pre-commit-config.yaml\nrepos:\n- repo: https://github.com/pre-commit/pre-commit-hooks\n  rev: v4.4.0\n  hooks:\n  - id: trailing-whitespace\n  - id: end-of-file-fixer\n  - id: check-yaml\n  - id: check-added-large-files\n\n- repo: https://github.com/psf/black\n  rev: 22.3.0\n  hooks:\n  - id: black\n\n- repo: https://github.com/pycqa/flake8\n  rev: 4.0.1\n  hooks:\n  - id: flake8\n```\n\n## Performance Considerations\n\n### Efficient Data Structures\n\nChoose the right data structures:\n\n```python\n# Use sets for membership testing\nvalid_items = {'apple', 'banana', 'orange'}\nif item in valid_items:  # O(1) lookup\n    pass\n\n# Use lists for ordered collections\nitems = ['apple', 'banana', 'orange']\n\n# Use dicts for key-value pairs\nprices = {'apple': 1.0, 'banana': 0.5, 'orange': 0.8}\n```\n\n### List Comprehensions\n\nUse list comprehensions for concise, readable code:\n\n```python\n# Good\nsquares = [x**2 for x in range(10) if x % 2 == 0]\n\n# Bad\nsquares = []\nfor x in range(10):\n    if x % 2 == 0:\n        squares.append(x**2)\n```\n\n### Generator Expressions\n\nUse generators for memory efficiency:\n\n```python\n# Memory efficient for large datasets\ndef get_large_data():\n    for i in range(1000000):\n        yield i * 2\n\n# Process data without loading everything into memory\ntotal = sum(get_large_data())\n```\n\n## Security Best Practices\n\n### Input Validation\n\nAlways validate user input:\n\n```python\ndef safe_sql_query(user_id: str) -> str:\n    \"\"\"Safely construct SQL query.\"\"\"\n    # Validate input\n    if not user_id.isdigit():\n        raise ValueError(\"Invalid user ID\")\n\n    # Use parameterized queries\n    return f\"SELECT * FROM users WHERE id = ?\", (user_id,)\n```\n\n### Environment Variables\n\nStore sensitive data securely:\n\n```python\nimport os\n\n# Good\nDATABASE_URL = os.getenv('DATABASE_URL')\nSECRET_KEY = os.getenv('SECRET_KEY')\n\n# Bad\nDATABASE_URL = \"postgresql://user:password@localhost/db\"\n```\n\n## Version Control\n\n### Commit Messages\n\nWrite clear, descriptive commit messages:\n\n```bash\n# Good\ngit commit -m \"Add user authentication feature\n\n- Implement login/logout functionality\n- Add password hashing with bcrypt\n- Create user registration endpoint\n- Add JWT token generation\"\n\n# Bad\ngit commit -m \"fix bug\"\n```\n\n### Branching Strategy\n\nUse a consistent branching strategy:\n\n```\nmain (production)\n├── develop (integration)\n│   ├── feature/user-auth\n│   ├── feature/payment-integration\n│   └── bugfix/login-validation\n```\n\n## Conclusion\n\nWriting clean, maintainable Python code requires discipline and attention to detail. By following these best practices, you'll create code that's easier to understand, test, and maintain.\n\nRemember that code is read much more often than it's written, so prioritize readability and maintainability. Use the tools and techniques outlined in this guide to establish good habits that will serve you throughout your Python development career.\n            ",
        "excerpt": "Master Python best practices for writing clean, maintainable code. Covers style, structure, testing, documentation, and performance optimization.",
        "image": "static/images/suresh.jpg",
        "author": 1,
        "tags": "Python, Best Practices, Clean Code, Development",
        "published": true,
        "published_at": null,
        "created_at": "2025-11-05T11:24:28.393Z",
        "updated_at": "2025-11-05T16:44:34.593Z"
    }
},
{
    "model": "blog.blogpost",
    "pk": 10,
    "fields": {
        "title": "Deploying Django Applications to AWS",
        "slug": "deploying-django-aws",
        "content": "\n# Deploying Django Applications to AWS\n\nAmazon Web Services (AWS) provides a robust platform for deploying Django applications. This comprehensive guide covers various deployment strategies, from simple EC2 instances to complex architectures using Elastic Beanstalk, ECS, and more.\n\n## AWS Services Overview\n\n### Elastic Beanstalk\nAWS Elastic Beanstalk is the fastest way to deploy Django applications. It handles:\n- Load balancing\n- Auto scaling\n- Health monitoring\n- Environment management\n\n### EC2 with Docker\nFor more control, deploy Django in Docker containers on EC2 instances.\n\n### ECS (Elastic Container Service)\nRun Django applications in containers with orchestration.\n\n### Lambda with API Gateway\nServerless deployment for cost-effective, scalable solutions.\n\n## Elastic Beanstalk Deployment\n\n### Prerequisites\n\n1. **AWS CLI Installation**\n```bash\npip install awscli\naws configure\n```\n\n2. **EB CLI Installation**\n```bash\npip install awsebcli\n```\n\n### Django Configuration for Production\n\n```python\n# settings.py\nimport os\n\nDEBUG = False\n\nALLOWED_HOSTS = [\n    '.elasticbeanstalk.com',\n    'yourdomain.com',\n]\n\n# Database\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': os.environ.get('RDS_DB_NAME'),\n        'USER': os.environ.get('RDS_USERNAME'),\n        'PASSWORD': os.environ.get('RDS_PASSWORD'),\n        'HOST': os.environ.get('RDS_HOSTNAME'),\n        'PORT': os.environ.get('RDS_PORT'),\n    }\n}\n\n# Static files\nSTATIC_URL = '/static/'\nSTATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')\n\n# Security\nSECRET_KEY = os.environ.get('SECRET_KEY')\nSECURE_SSL_REDIRECT = True\nSESSION_COOKIE_SECURE = True\nCSRF_COOKIE_SECURE = True\n```\n\n### Application Structure\n\n```\nmyproject/\n├── .ebextensions/\n│   ├── 01_packages.config\n│   ├── 02_django.config\n│   └── 03_postgres.config\n├── .platform/\n│   └── hooks/\n│       └── predeploy/\n│           └── 01_migrate.sh\n├── requirements.txt\n├── manage.py\n└── myapp/\n```\n\n### EB Extensions Configuration\n\n```yaml\n# .ebextensions/01_packages.config\npackages:\n  yum:\n    git: []\n    postgresql-devel: []\n    python3-devel: []\n\ncontainer_commands:\n  01_collectstatic:\n    command: \"python manage.py collectstatic --noinput\"\n    leader_only: true\n```\n\n```yaml\n# .ebextensions/02_django.config\noption_settings:\n  aws:elasticbeanstalk:application:environment:\n    DJANGO_SETTINGS_MODULE: myproject.settings\n  aws:elasticbeanstalk:environment:proxy:staticfiles:\n    /static: staticfiles\n  aws:autoscaling:launchconfiguration:\n    InstanceType: t3.micro\n    IamInstanceProfile: aws-elasticbeanstalk-ec2-role\n```\n\n```yaml\n# .ebextensions/03_postgres.config\nResources:\n  AWSEBRDSDatabase:\n    Type: AWS::RDS::DBInstance\n    Properties:\n      DBInstanceClass: db.t3.micro\n      DBEngine: postgres\n      DBEngineVersion: \"13.7\"\n      DBName: ebdb\n      AllocatedStorage: \"20\"\n```\n\n### Deployment Commands\n\n```bash\n# Initialize EB application\neb init -p python-3.9 my-django-app\n\n# Create environment\neb create django-env\n\n# Deploy\neb deploy\n\n# Open application\neb open\n```\n\n## Docker Deployment on EC2\n\n### Dockerfile\n\n```dockerfile\nFROM python:3.9-slim\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE 1\nENV PYTHONUNBUFFERED 1\n\n# Set work directory\nWORKDIR /code\n\n# Install dependencies\nCOPY requirements.txt /code/\nRUN pip install --upgrade pip\nRUN pip install -r requirements.txt\n\n# Copy project\nCOPY . /code/\n\n# Collect static files\nRUN python manage.py collectstatic --noinput\n\n# Run the application\nCMD [\"gunicorn\", \"--bind\", \"0.0.0.0:8000\", \"myproject.wsgi:application\"]\n```\n\n### Docker Compose for Local Development\n\n```yaml\nversion: '3.8'\n\nservices:\n  web:\n    build: .\n    command: python manage.py runserver 0.0.0.0:8000\n    volumes:\n      - .:/code\n    ports:\n      - \"8000:8000\"\n    environment:\n      - DEBUG=1\n    depends_on:\n      - db\n\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_DB: myproject\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf\n    depends_on:\n      - web\n```\n\n### EC2 Deployment Steps\n\n1. **Launch EC2 Instance**\n```bash\naws ec2 run-instances   --image-id ami-0abcdef1234567890   --count 1   --instance-type t3.micro   --key-name my-key-pair   --security-groups my-security-group\n```\n\n2. **Install Docker on EC2**\n```bash\nsudo yum update -y\nsudo amazon-linux-extras install docker\nsudo service docker start\nsudo usermod -a -G docker ec2-user\n```\n\n3. **Deploy Application**\n```bash\n# Clone repository\ngit clone https://github.com/yourusername/myproject.git\ncd myproject\n\n# Build and run\ndocker-compose up -d\n```\n\n## Serverless Deployment with Lambda\n\n### Zappa Configuration\n\nZappa makes it easy to deploy Django to AWS Lambda:\n\n```bash\npip install zappa\nzappa init\n```\n\n```json\n// zappa_settings.json\n{\n  \"dev\": {\n    \"django_settings\": \"myproject.settings\",\n    \"project_name\": \"myproject\",\n    \"runtime\": \"python3.9\",\n    \"s3_bucket\": \"myproject-zappa\",\n    \"aws_region\": \"us-east-1\",\n    \"environment_variables\": {\n      \"DEBUG\": \"False\"\n    }\n  }\n}\n```\n\n### Django Settings for Lambda\n\n```python\n# settings.py\nimport os\n\nif os.environ.get('AWS_LAMBDA_FUNCTION_NAME'):\n    # Running on Lambda\n    DEBUG = False\n    DATABASES = {\n        'default': {\n            'ENGINE': 'django.db.backends.postgresql',\n            'NAME': os.environ.get('DB_NAME'),\n            'USER': os.environ.get('DB_USER'),\n            'PASSWORD': os.environ.get('DB_PASSWORD'),\n            'HOST': os.environ.get('DB_HOST'),\n            'PORT': os.environ.get('DB_PORT'),\n        }\n    }\nelse:\n    # Local development\n    DEBUG = True\n    DATABASES = {\n        'default': {\n            'ENGINE': 'django.db.backends.sqlite3',\n            'NAME': BASE_DIR / 'db.sqlite3',\n        }\n    }\n```\n\n### Deploy to Lambda\n\n```bash\nzappa deploy dev\nzappa update dev\n```\n\n## Database Setup\n\n### RDS PostgreSQL\n\n```bash\naws rds create-db-instance   --db-instance-identifier my-django-db   --db-instance-class db.t3.micro   --engine postgres   --engine-version 13.7   --master-username myuser   --master-user-password mypassword   --allocated-storage 20\n```\n\n### Database Migration\n\n```bash\n# For Elastic Beanstalk\neb ssh\ncd /var/app/current\npython manage.py migrate\n```\n\n## Security Best Practices\n\n### Environment Variables\n\nStore sensitive configuration in environment variables:\n\n```python\n# settings.py\nimport os\n\nSECRET_KEY = os.environ.get('SECRET_KEY')\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': os.environ.get('DB_NAME'),\n        'USER': os.environ.get('DB_USER'),\n        'PASSWORD': os.environ.get('DB_PASSWORD'),\n        'HOST': os.environ.get('DB_HOST'),\n        'PORT': os.environ.get('DB_PORT'),\n    }\n}\n```\n\n### HTTPS Configuration\n\nAlways use HTTPS in production:\n\n```python\n# settings.py\nSECURE_SSL_REDIRECT = True\nSESSION_COOKIE_SECURE = True\nCSRF_COOKIE_SECURE = True\nSECURE_HSTS_SECONDS = 31536000  # 1 year\nSECURE_HSTS_INCLUDE_SUBDOMAINS = True\nSECURE_HSTS_PRELOAD = True\n```\n\n## Monitoring and Logging\n\n### CloudWatch Integration\n\nSet up monitoring with AWS CloudWatch:\n\n```python\n# settings.py\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'aws': {\n            'format': '%(asctime)s [%(levelname)s] %(name)s: %(message)s'\n        },\n    },\n    'handlers': {\n        'watchtower': {\n            'level': 'INFO',\n            'class': 'watchtower.CloudWatchLogHandler',\n            'log_group': 'django-app',\n            'stream_name': 'application',\n            'formatter': 'aws',\n        },\n    },\n    'loggers': {\n        'django': {\n            'handlers': ['watchtower'],\n            'level': 'INFO',\n        },\n    },\n}\n```\n\n## Cost Optimization\n\n### Auto Scaling\n\nConfigure auto scaling based on demand:\n\n```yaml\n# .ebextensions/autoscaling.config\nResources:\n  AWSEBAutoScalingGroup:\n    Type: AWS::AutoScaling::AutoScalingGroup\n    Properties:\n      MinSize: \"1\"\n      MaxSize: \"4\"\n      DesiredCapacity: \"2\"\n      TargetGroupARNs:\n        - Ref: AWSEBLoadBalancerTargetGroup\n```\n\n### Reserved Instances\n\nConsider reserved instances for predictable workloads to reduce costs.\n\n## Conclusion\n\nAWS provides multiple deployment options for Django applications, each with different trade-offs between ease of use, control, and cost. Elastic Beanstalk offers the fastest path to production, while EC2 with Docker provides maximum control. Lambda with Zappa is ideal for serverless deployments.\n\nChoose the deployment strategy that best fits your application requirements, team expertise, and scaling needs. Always implement proper security measures, monitoring, and backup strategies regardless of the chosen approach.\n\nThe key to successful AWS deployment is understanding your application's architecture and selecting the right AWS services to support it efficiently and cost-effectively.\n            ",
        "excerpt": "Learn how to deploy Django applications to AWS using various services like Elastic Beanstalk, EC2, ECS, and Lambda. Includes production configuration and best practices.",
        "image": "static/images/suresh1.jpg",
        "author": 1,
        "tags": "Django, AWS, Deployment, Cloud",
        "published": true,
        "published_at": null,
        "created_at": "2025-11-05T11:24:28.402Z",
        "updated_at": "2025-11-05T16:44:34.604Z"
    }
}
]
